import { 
  collection, 
  addDoc, 
  query, 
  where, 
  orderBy, 
  limit, 
  getDocs,
  serverTimestamp
} from 'firebase/firestore';
import { firestore } from '../firebase';
import type { ChatMessage, ChatMessageInput } from '../components/Chat/types';

/**
 * Firestore Document Structure (for reference):
 * Path: canvases/{canvasId}/chatMessages/{messageId}
 * {
 *   id: string;               // Auto-generated by Firestore
 *   userId: string;           // User identifier
 *   role: 'user' | 'assistant';
 *   content: string;          // Message text
 *   createdAt: Timestamp;     // Firestore serverTimestamp()
 * }
 */

/**
 * Get chat messages collection path for a specific canvas
 */
function getChatMessagesPath(canvasId: string): string {
  return `canvases/${canvasId}/chatMessages`;
}

/**
 * Saves a chat message to Firestore (canvas-scoped)
 * 
 * @param canvasId - Canvas ID where message belongs
 * @param message - Message data (userId, role, content)
 * @returns Promise<string> - Document ID of saved message
 * @throws Error if validation fails or save fails
 */
export async function saveMessage(canvasId: string, message: Omit<ChatMessageInput, 'canvasId'>): Promise<string> {
  // Validate input
  if (!canvasId || canvasId.trim() === '') {
    throw new Error('Canvas ID is required');
  }
  
  if (!message.userId || message.userId.trim() === '') {
    throw new Error('User ID is required');
  }
  
  if (!message.content || message.content.trim() === '') {
    throw new Error('Message content is required');
  }
  
  if (message.content.length > 10000) {
    throw new Error('Message content exceeds maximum length of 10,000 characters');
  }
  
  if (!['user', 'assistant'].includes(message.role)) {
    throw new Error('Message role must be "user" or "assistant"');
  }

  try {
    // Create Firestore document with serverTimestamp (canvas-scoped)
    const messagesPath = getChatMessagesPath(canvasId);
    const messagesRef = collection(firestore, messagesPath);
    const docRef = await addDoc(messagesRef, {
      userId: message.userId,
      role: message.role,
      content: message.content,
      createdAt: serverTimestamp()
    });

    return docRef.id;
  } catch (error) {
    console.error('Failed to save message:', error);
    throw error;
  }
}

/**
 * Loads chat history for a specific canvas and user
 * 
 * @param canvasId - Canvas ID to load messages for
 * @param userId - User ID to load messages for
 * @param messageLimit - Maximum number of messages to load (default: 100)
 * @returns Promise<ChatMessage[]> - Array of messages (oldest first)
 * @throws Error if query fails
 */
export async function loadChatHistory(
  canvasId: string, 
  userId: string,
  messageLimit: number = 100
): Promise<ChatMessage[]> {
  // Validate input
  if (!canvasId || canvasId.trim() === '') {
    throw new Error('Canvas ID is required');
  }
  
  if (!userId || userId.trim() === '') {
    throw new Error('User ID is required');
  }

  try {
    // Build Firestore query (canvas-scoped)
    const messagesPath = getChatMessagesPath(canvasId);
    const messagesRef = collection(firestore, messagesPath);
    const q = query(
      messagesRef,
      where('userId', '==', userId),
      orderBy('createdAt', 'asc'),
      limit(messageLimit) // Performance safeguard
    );

    // Execute query
    const querySnapshot = await getDocs(q);

    // Map Firestore documents to ChatMessage interface
    const messages: ChatMessage[] = querySnapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        role: data.role as 'user' | 'assistant',
        content: data.content,
        // Convert Firestore Timestamp to JavaScript Date
        // Fallback to current date if timestamp is missing (shouldn't happen)
        timestamp: data.createdAt?.toDate ? data.createdAt.toDate() : new Date()
      };
    });

    return messages;
  } catch (error) {
    console.error('Failed to load chat history:', error);
    // Return empty array on error (don't crash)
    return [];
  }
}

/**
 * Deletes a chat message from Firestore
 * 
 * @param canvasId - Canvas ID where message belongs
 * @param messageId - Document ID of the message to delete
 * @returns Promise<void>
 * @throws Error if delete fails
 */
export async function deleteMessage(canvasId: string, messageId: string): Promise<void> {
  if (!canvasId || canvasId.trim() === '') {
    throw new Error('Canvas ID is required');
  }
  
  if (!messageId || messageId.trim() === '') {
    throw new Error('Message ID is required');
  }

  try {
    const { doc, deleteDoc } = await import('firebase/firestore');
    const messagesPath = getChatMessagesPath(canvasId);
    const messageRef = doc(firestore, messagesPath, messageId);
    await deleteDoc(messageRef);
  } catch (error) {
    console.error('Failed to delete message:', error);
    throw error;
  }
}

/**
 * Optional: Subscribes to real-time chat history updates
 * 
 * @param canvasId - Canvas ID to subscribe to
 * @param userId - User ID to subscribe for
 * @param callback - Function called when messages change
 * @returns Unsubscribe function
 */
// Commented out for now - implement later if needed for real-time sync across tabs
/*
export function subscribeToChatHistory(
  canvasId: string,
  userId: string,
  callback: (messages: ChatMessage[]) => void
): () => void {
  const messagesPath = getChatMessagesPath(canvasId);
  const messagesRef = collection(firestore, messagesPath);
  const q = query(
    messagesRef,
    where('userId', '==', userId),
    orderBy('createdAt', 'asc'),
    limit(100)
  );

  const unsubscribe = onSnapshot(q, (snapshot) => {
    const messages: ChatMessage[] = snapshot.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        role: data.role as 'user' | 'assistant',
        content: data.content,
        timestamp: data.createdAt?.toDate ? data.createdAt.toDate() : new Date()
      };
    });
    callback(messages);
  });

  return unsubscribe;
}
*/
